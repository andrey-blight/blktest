# BLKTEST

### Приложение для тестирования производительности блочных устройств через fio.

Запуск приложение происходит посредством запуска bash скрипта

Перед запуском нужно проверить установлены ли fio и gnuplot, если нет то выполнить:

```console
sudo apt install fio gnuplot
```

1) Даем bash скрипту право на исполнение
2) Запускаем приложение (средний тест проходит за 10-20 минут)

```console
chmod +x blktest
```

```console
./blktest -name=testname -filename=filename -output=path/to/plot.png
```

### Параметры:

name - Название теста

filename - Название файла или устройства на котором будет проходить тест

output - Название файла куда будет сохранен график latency от iodepth

## Реализация

Bash скрипт парсит параметры и запускает с ними `main.py`. Проект содержит несколько модулей. Первый из них -
логирование `logger.py`. Логи пишутся в `logs/blktest.log` - info уровень логов и `logs/blktest_debug.log` - debug
уровень логирования

Реализовано два класса для работы с fio, FioExecutor запускает fio с переданными параметрами, FioParser достает
read latency и write latency из stdout отработанного fio при помощи регулярных выражений

Параметр iodepth выбирается логарифмически (то есть сначала более мелкие значения, и потом с более большим шагом до 256)

## Описание результатов

Я сделал два теста:

Первый на Ubuntu с использованием движка libaio. Вот ссылка на [график](static/ubuntu.png). По результатам видно, что
задержка чтения сначала примерно такая же, как и записи, но при больших iodepth задержка записи иногда
значительно больше, чем чтения. Так же ясен тренд на увеличение задержки при увеличении числа потоков. В отличии от
macOS, Ubuntu не оптимизирует запросы и видна экспоненциальная зависимость. Важно правильно подобрать iodepth,
чтобы сохранить большой IOPS и приемлемую задержку.

Второй на MacOS с использованием движка posixaio. Вот ссылка на [график](static/macOS.png). По результатам видно,
что задержка чтения и записи почти эквивалентная. Задрежка сильно растет и останавливается примерно на iodepth=16.
Дальше от 16 до 256 latency остается примерно одинаковым. Это может свидетельствовать о том, что несмотря на
запрет кеширования (direct=1) MacOS кеширует и каким либо образом оптимизирует запросы к диску.